---
title: "Master script for TNBC typing project"
author: "Amy Gill"
date: "5/4/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script combines several independent scripts so that all the code for this project is in one place.

Component scripts:

`1-get-data.Rmd`


## Libraries and color scheme

```{r message=FALSE}
library(stringr)
library(tidyverse)
library(SingleCellExperiment)
library(Seurat)
library(pdftools)
library(ggrepel)
library(SC3)

# black, red, skyblue, orange, green, yellow, darkblue, pink 
colorblind_palette <- c("#000000", "#D55E00",  "#56B4E9", "#E69F00", "#009E73", "#F0E442", "#0072B2",  "#CC79A7")
```

## Import single cell data from GEO

### Original paper

Karaayvaz M, Cristea S, Gillespie SM, Patel AP et al. Unravelling subclonal heterogeneity and aggressive disease states in TNBC through single-cell RNA-seq. Nat Commun 2018 Sep 4;9(1):3588. PMID: 30181541

https://www-ncbi-nlm-nih-gov.proxy1.library.jhu.edu/geo/query/acc.cgi?acc=GSE118389

### Dataset on GEO

GEO link: https://www-ncbi-nlm-nih-gov.proxy1.library.jhu.edu/geo/query/acc.cgi?acc=GSE118389

### Download data

#### TPM counts before normalization

- Downloaded `GSE118389_tpm_rsem.txt.gz` to `data/`.
- Unzipped with `gunzip data/GSE118389_tpm_rsem.txt.gz`

#### Normalized data

- Downloaded `GSE118398_norm_data.txt.gz` to `data/`.
- Unzipped with `gunzip data/GSE118389_norm_data.txt.gz`

#### Metadata

- Downloaded `GSE118389_series_matrix.txt.gz` to `data/`.
- Unzipped with `gunzip data/GSE118389_series_matrix.txt.gz`

##### Overall design

"Single cell RNA sequencing of 1,534 cells in six fresh triple negative breast cancer tumors."

##### Sample collection protocol

"Fresly collected human tumor samples were mechanically and enzymatically digested using tumor dissociation kit (Miltenyi Biotec). Single cells were sorted by flow cytometry, lysed and snap frozen on dry ice immediately."

##### Library preparation

"RNA libraries were prepared using Smart-seq2 protocol (Picelli et al., 2014)"

##### Sequencing instrument

Illumina Genome Analyzer

##### Genome build

GRCh38

##### TPM calculations

"Fastq files were quantified to transcript per million (TPM) expression values with RSEM with default parameters"

##### Removing low quality cells

"Low quality cells were filtered as follows: 4 median absolute deviations (MADs) below the median for any of the three metrics concering: i) library size; ii) number of expressed genes; iii) total amount of mRNA"

##### Removing unexpressed genes

"Unexpressed genes were removed as follows: a gene was considered unexpressed if log2(TPM+1) < 0.1 in at least 95% of cells separately for each patient"

##### Normalization

"Data was normalized following a three-step combination approach: i) Transform the TPM values into relative counts with the Census algorithm (Qiu et al, 2017); ii) Normalize the Census counts with the deconvolution strategy implemented in scran (Lun et al 2016); iii) Remove additional sources of variation with RUVSeq (Risso et al, 2014)"



### Format normalized data

#### Read normalized data

```{r}
# import as data frame
tnbc <- read.table("data/GSE118389_norm_data.txt")

# convert to matrix
tnbc_mat <- as.matrix(tnbc)
```

#### Create column data

All samples are from human triple negative breast cancer and were processed identically. The main factor that differs between samples is that they come from 6 different patients. Patient ID is embedded in the sample name.

```{r}
# extract patient ID from column name
patient_id <- sapply(1:length(colnames(tnbc)), function(i){
	str_split(colnames(tnbc)[i], pattern = "_")[[1]][1]    # portion of the column name before the first underscore
})

# table of number of cells per patient - as expected, matches original publication
data.frame(table(patient_id)) %>%
	mutate("Patient ID" = patient_id,
		   "Number of cells" = Freq) %>%
	select(-c(patient_id, Freq))
```

```{r}
# bind sample ID and patient ID into data frame
coldata <- DataFrame(sample_id = colnames(tnbc),
					  patient_id = patient_id)

# set row names to sample ID for compatibility with SingleCellExperiment format
rownames(coldata) <- colnames(tnbc)
```

#### Create row data

Initial row data consists only of gene names, which are currently the row names of the expression matrix

```{r}
# add feature symbols (gene names)
rowdata <- data.frame(feature_symbol = rownames(tnbc))

# add row names for proper SingleCellExperiment functionality (gene names)
rownames(rowdata) <- rownames(tnbc)
```

#### Convert to SingleCellExperiment format

```{r}
sce <- SingleCellExperiment(tnbc_mat)    # add normalized count data
colData(sce) <- coldata    # add sample info
rowData(sce) <- rowdata    # add gene info

# set name of assay for compatibility with downstream tools
# (some algorithms threw errors when there was no counts or logcounts, and these data are not log-normalized)
names(assays(sce)) <- "normcounts"

# save to rda format
save(sce, file = "rdata/sce.rda")
```

### Create alternate SingleCellExperiment with TPM counts before normalization

SC3 requires the TPM counts in addition to the normalized counts in order to calculate dropout. I created a separate `sce_tpm` object for this instead of modifying `sce` because I had already done downstream processing that used the normcounts slot, and I didn't want to risk breaking anything.

```{r}
# read TPM data
tpm <- read.table("data/GSE118389_tpm_rsem.txt")
tpm <- as.matrix(tpm)

# extract patient ID from column names
pt_id_tpm <- sapply(1:length(colnames(tpm)), function(i){
	str_split(colnames(tpm)[i], pattern = "_")[[1]][1]    # portion of the column name before the first underscore
})

# bind sample ID and patient ID into data frame
coldata_tpm <- DataFrame(sample_id = colnames(tpm),
					  patient_id = pt_id_tpm)

# set row names to sample ID for compatibility with SingleCellExperiment format
rownames(coldata_tpm) <- colnames(tpm)

# create rowData from row names
rowdata_tpm <- data.frame(feature_symbol = rownames(tpm))
rownames(rowdata_tpm) <- rownames(tpm)

# create SingleCellExperiment with TPM
sce_tpm <- SingleCellExperiment(tpm)    # add TPM data
colData(sce_tpm) <- coldata_tpm    # add sample info
rowData(sce_tpm) <- rowdata_tpm    # add gene info

names(assays(sce_tpm)) <- "counts"

# save as rda
save(sce_tpm, file = "rdata/sce_tpm.rda")
```

### Create Seurat object from SingleCellExperiment

```{r}
tnbc_seurat <- as.Seurat(sce, counts = "normcounts", data = "normcounts")
```
### Checkpoint: Seurat object before scaling and regression

```{r}
tnbc_seurat_pre_reg <- tnbc_seurat
save(tnbc_seurat_pre_reg, file = "rdata/tnbc_seurat_pre_reg.rda")
```


## Preprocessing

### Regress out patient effect

In the original paper, clustering was performed after regressing out patient-specific effects. Therefore, I will do the same.

```{r}
# scale data while regressing out patient_id variable
tnbc_seurat <- ScaleData(tnbc_seurat, vars.to.regress = "patient_id", features = rownames(tnbc_seurat))
```

### Find variable features

```{r}
# identify 2000 most variable features
tnbc_seurat <- FindVariableFeatures(tnbc_seurat, selection.method = "vst", nfeatures = 2000)

# create variable feature plot
p1 <- VariableFeaturePlot(tnbc_seurat)

# label top 8 most variable features
top8 <- head(VariableFeatures(tnbc_seurat), 8)
p2 <- LabelPoints(plot = p1, points = top8, repel = TRUE, xnudge = 0.05, ynudge = 0.01)

# view variable feature plot
p2

# save labeled variable feature plot
ggsave(p2, filename = "results/var-features.png", height = 4, width = 7)
```

### Dimensionality reduction and projection

#### Principal component analysis

```{r}
# perform PCA with the 2000 most variable features
tnbc_seurat <- RunPCA(tnbc_seurat, features = VariableFeatures(tnbc_seurat))
```

#### tSNE

```{r}
# run tSNE on the top 50 PCs
tnbc_seurat <- RunTSNE(tnbc_seurat, dims = 1:50)
```


#### UMAP

```{r}
# run UMAP on the top 50 PCs with the R-native UWOT method and cosine metric
tnbc_seurat <- RunUMAP(tnbc_seurat, dims = 1:50)
```

### Color tSNE and UMAP by patient ID

#### tSNE

```{r}
# color tSNE plot by patient ID
patient_tsne <- DimPlot(tnbc_seurat, reduction = "tsne", group.by = "patient_id") +
	ggtitle("tSNE plot of patients after removing patient effect") +
	scale_color_manual(values = colorblind_palette[c(1:5,8)])

# inspect tSNE plot colored by patient ID
patient_tsne

# save tSNE plot colored by patient ID
ggsave(patient_tsne, filename = "results/patient-tsne.png", width = 7, height = 4)
```

#### UMAP

```{r}
# color UMAP plot by patient ID
patient_umap <- DimPlot(tnbc_seurat, reduction = "umap", group.by = "patient_id") +
	ggtitle("UMAP plot of patients after removing patient effect") +
	scale_color_manual(values = colorblind_palette[c(1:5,8)])

# inspect UMAP plot colored by patient ID
patient_umap

# save UMAP plot colored by patient ID
ggsave(patient_umap, filename = "results/patient-umap.png", width = 7, height = 4)
```


## Louvain clustering with Seurat

### Find neighbors

```{r}
# compute nearest neighbor graph and shared nearest neighbors (SNN) at the cell level
tnbc_seurat <- FindNeighbors(tnbc_seurat, dims = 1:50)
```

### Testing clustering resolutions

The tested range of resolution parameters was suggested by the [Seurat clustering tutorial](https://satijalab.org/seurat/articles/pbmc3k_tutorial.html) for datasets of up to 3000 cells.

```{r}
# run clustering with a range of resolution parameters
rez <- seq(0.4, 1.2, 0.1)
clust <- sapply(rez, function(x){
	trez <- FindClusters(tnbc_seurat, resolution = x)
	length(table(Idents(trez)))
})
rez_clust <- data.frame(rez, clust)

# scatter plot and curve fit for number of clusters versus Louvain resolution parameter
gg_rez_clust <- rez_clust %>%
	ggplot(aes(rez, clust)) +
	geom_point() + 
	geom_line() +
	xlab("Resolution parameter of Louvain clustering") +
	ylab("Number of clusters") +
	ggtitle("Clusters identified at different resolutions by the Louvain algorithm") +
	ylim(c(5,20))

# view plot of number of clusters versus resolution
gg_rez_clust

# save clustering resolution plot
ggsave(gg_rez_clust, file = "results/clustering-resolutions.png", height = 4, width = 6)
```

At resolutions greater than or equal to 1, there are 18 clusters. Moving forward, I use a resolution of 1.

### Perform clustering

```{r}
# Louvain clustering with a resolution of 1
tnbc_seurat <- FindClusters(tnbc_seurat, resolution = 1)

# number of cells per Louvain cluster
table(tnbc_seurat$seurat_clusters)
```

### tSNE plot of Louvain clusters

```{r}
# color tSNE plot by Louvain clusters
louvain_tsne <- DimPlot(tnbc_seurat, reduction = "tsne",
		group.by = "seurat_clusters",
		label = TRUE, label.size = 5, repel = TRUE) +
	ggtitle("tSNE plot of Louvain clusters")

# inspect tSNE plot of Louvain clusters
louvain_tsne

# save tSNE plot of Louvain clusters
ggsave(louvain_tsne, filename = "results/louvain_tsne.png", height = 4, width = 7)
```


### UMAP plot of Louvain clusters

```{r}
# color UMAP plot by Louvain clusters
louvain_umap <- DimPlot(tnbc_seurat, reduction = "umap",
		group.by = "seurat_clusters",
		label = TRUE, label.size = 5, repel = TRUE) +
	ggtitle("UMAP plot of Louvain clusters")

# inspect UMAP plot of Louvain clusters
louvain_umap

# save UMAP plot of Louvain clusters
ggsave(louvain_umap, filename = "results/louvain_umap.png", height = 4, width = 7)
```
### Differentially expressed genes in Seurat clusters

```{r}
# find genes differentially expressed in one cluster versus all other clusters with log fold change >= 0.5
seurat_markers <- FindAllMarkers(tnbc_seurat, logfc.threshold = 0.5, slot = "scale.data")

# keep only differentially expressed markers with an adjusted pval less than .05
seurat_markers <- seurat_markers %>%
	filter(p_val_adj <= .05)

# save marker genes
save(seurat_markers, file = "rdata/seurat_markers.rda")

# define top 5 differentially expressed genes in each cluster
top5 <- seurat_markers %>%
	group_by(cluster) %>%
	top_n(5, wt = avg_diff)

louvain_de_heat <- DoHeatmap(tnbc_seurat, features = top5$gene, size = 3, slot = "scale.data") + NoLegend()

louvain_de_heat

ggsave(louvain_de_heat, filename = "results/louvain-de-genes-heat.png", width = 10, height = 10)
```

### Save updated Seurat and SingleCellExperiment objects

```{r}
# save updated tnbc_seurat object
save(tnbc_seurat, file = "rdata/tnbc_seurat.rda")

# create updated sce object
sce_post_seurat <- as.SingleCellExperiment(tnbc_seurat)
save(sce_post_seurat, file = "rdata/sce_post_seurat.rda")
```

## Aside: tSNE and UMAP showing patient ID before regressing out patient effect

### Preprocessing to run tSNE and UMAP before removing patient effect

```{r}
# find variable features without removing patient effect
tnbc_seurat_pre_reg <- FindVariableFeatures(tnbc_seurat_pre_reg, selection.method = "vst", nfeatures = 2000)

# center and scale data without removing patient effect
tnbc_seurat_pre_reg <- ScaleData(tnbc_seurat_pre_reg, features = rownames(tnbc_seurat_pre_reg))

# PCA without removing patient effect
tnbc_seurat_pre_reg <- RunPCA(tnbc_seurat_pre_reg, features = VariableFeatures(tnbc_seurat_pre_reg))
```

### tSNE plot of patients before removing patient effect

```{r}
# run tSNE without removing patient effect
tnbc_seurat_pre_reg <- RunTSNE(tnbc_seurat_pre_reg, dims = 1:50)

# create tSNE plot without removing patient effect and color by patient
tsne_patient_pre_reg <- DimPlot(tnbc_seurat_pre_reg, reduction = "tsne",
		group.by = "patient_id") +
	ggtitle("tSNE plot of patients before removing patient effect") +
	scale_color_manual(values = colorblind_palette[c(1:5,8)])

# inspect tSNE plot created without removing patient effect
tsne_patient_pre_reg

# save tSNE plot created without removing patient effect
ggsave(tsne_patient_pre_reg, filename = "results/tsne-patient-pre-reg.png", width = 7, height = 4)
```

### UMAP plot of patients before removing patient effect

```{r}
# run UMAP without removing patient effect
tnbc_seurat_pre_reg <- RunUMAP(tnbc_seurat_pre_reg, dims = 1:50)

# create tSNE plot without removing patient effect and color by patient
umap_patient_pre_reg <- DimPlot(tnbc_seurat_pre_reg, reduction = "umap",
		group.by = "patient_id") +
	ggtitle("UMAP plot of patients before removing patient effect") +
	scale_color_manual(values = colorblind_palette[c(1:5,8)])

# inspect UMAP plot created without removing patient effect
umap_patient_pre_reg

# save tSNE plot created without removing patient effect
ggsave(umap_patient_pre_reg, filename = "results/umap-patient-pre-reg.png", width = 7, height = 4)
```

## Marker gene based cell typing (a.k.a literature-based cell typing)

### Importing marker gene list

These data were imported from the PDF of supplementary table 7 of Karaayvaz et al., 2018.

#### Paper description of marker genes and classification strategy

"The literature-based list used to classify cell types consists of 49 expression markers specific to four cell types, compiled from multiple references (Tirosh et al., 2016) (Table 7). In order to minimize the number of misassignments, we only assign cells to a specific cell type when we consider that there is enough expression-based evidence supporting the assignment (expression threshold = 1). To this end, we derive a series of expert-based rules:

1. Epithelial class: a cell has epithelial characteristics if it expresses either:

- at least 2 epithelial markers;

- only one of the strongest breast epithelial markers: EPCAM, KRT8, KRT18, KRT19, with expression
higher than in 50% of the cells for that respective patient, for that marker.

2. Specific immune class: a cell has specific immune characteristics (T cell, B cell, macrophage) if it expresses
either:

-only specific immune markers of that type (at least 2);

-PTPRC and only specific immune markers of that type (at least 1);

-at least 3 immune markers of that type, and at most 1 immune marker of another type.

3. Stroma class: a cell has stroma characteristics if it expresses either:

- only stroma markers;

- at least 3 stroma markers and at most 1 endothelial marker.

4. Endothelial class: a cell has endothelial characteristics if it expresses either:

- only endothelial markers;

- at least 3 endothelial markers and at most 1 stroma marker."

#### Import marker gene table from PDF of supplement

```{r}
supp <- pdf_text("paper/supplement.pdf")
```

Supplementary table 7 is split across pages 35 and 36. First extract the rows of the table from page 35:

```{r}
# extract page 35 of the supplement as text
p35 <- supp[[35]]

# split into a vector of lines
p35_split <- str_split(p35, "\r\n")[[1]]

# remove leading and trailing whitespace
p35_split <- str_trim(p35_split)

# start building vector to turn into table 
s7_dat <- p35_split[14:50]
```

Append the rows of the table from page 36:

```{r}
# extract page 36 of the supplement as text
p36 <- supp[[36]]

# split into a vector of lines
p36_split <- str_split(p36, "\r\n")[[1]]

# remove leading and trailing whitespace
p36_split <- str_trim(p36_split)

# append to vector 
s7_dat <- c(s7_dat, p36_split[1:12])
```

Split the elements of the vector on whitespace. The first chunk of each element is the marker gene, the second chunk is the cell type indicated by that marker gene, and the third chunk (when present) is the cell subtype indicated by that marker gene.

```{r}
# split on more than one space
s7_split <- str_split(s7_dat, pattern = "\\s\\s+")

# extract marker gene name (first elements of s7_split)
marker <- sapply(1:length(s7_split), function(i){
	s7_split[[i]][1]
})

# extract cell type indicated by marker (second elements of s7_split)
cell_type <- sapply(1:length(s7_split), function(i){
	s7_split[[i]][2]
})

# extract cell subtype indicated by marker (third elements of s7_split, if they exist)
cell_subtype <- sapply(1:length(s7_split), function(i){
	ifelse(length(s7_split[[i]]) > 2, s7_split[[i]][3], NA)
})
```

Combine the marker gene, cell type and cell subtype into a data frame, then save that data frame.

```{r}
# create data frame of cell type markers
cell_type_markers <- data.frame(marker = marker,
		   cell_type = cell_type,
		   cell_subtype = cell_subtype)

# save table of cell type markers
save(cell_type_markers, file = "rdata/cell_type_markers.rda")
```

### Analyzing expression of marker genes

Check which cells express each of the marker genes above a threshold of 1

```{r}
# pull normalized counts into separate matrix - shorthand for easy calling of count matrix
ct <- logcounts(sce_post_seurat)

# pull colData into separate editable data frame
# goal: track expression of various markers in the cells without modifying colData in place
df <- colData(sce_post_seurat)

# label cells that express each of the marker genes above a threshold of 1
for (i in 1:nrow(cell_type_markers)) {
	gene <- cell_type_markers$marker[i]
	df[, gene] <- ct[gene,] > 1
}

# inspect data frame - TRUE/FALSE column for each marker gene denoting whether expr > 1
# df
```

### Find epithelial cells

#### Pull epithelial markers and strong epithelial markers

```{r}
# all genes defined as epithelial markers
epi_markers <- cell_type_markers %>%
	filter(cell_type == "epithelial") %>%
	pull(marker)

# 4 genes defined as strong epithelial markers
strong_epi_markers <- c("EPCAM", "KRT8", "KRT18", "KRT19")
```

#### Case 1: Cell expresses at least 2 epithelial markers

```{r}
# calculate number of epithelial genes expressed above a threshold of 1
epi <- df[, epi_markers]
epi_counts <- rowSums(as.matrix(epi))

hist(epi_counts)
```
```{r}
# mark cells as epithelial if they pass case 1
df$epithelial <- epi_counts >= 2
table(df$epithelial)
```

#### Case 2: Cells highly express only one strong epithelial marker

Cells express only one of the strongest markers (EPCAM, KRT8, KRT18, KRT19) with expression higher than 50% of the cells for that patient, for that marker.

```{r}
# inspect strong_epi_markers in cells with an epi_count of 1
strong_epi <- df[epi_counts == 1, strong_epi_markers]

# remove cells without significant expr of the strong_epi markers from strong_epi
strong_epi <- strong_epi[rowSums(as.matrix(strong_epi)) > 0,]


# from strong_epi, extract the single expressed marker whose expression must be compared to median for that pt
marker_test <- data.frame(
	sample_id = rownames(strong_epi),
	patient_id = df[df$sample_id %in% rownames(strong_epi), "patient_id"],
	marker = case_when(
		strong_epi$EPCAM ~ "EPCAM",
		strong_epi$KRT8 ~ "KRT8",
		strong_epi$KRT18 ~ "KRT18",
		strong_epi$KRT19 ~ "KRT19"
	)
)

# create data frame to store patient-specific median expression for strong_epi_markers
pt_epi_df <- data.frame(patient_id = names(table(sce_post_seurat$patient_id)))

# find patient-specific median expression for strong_epi_markers
for (i in 1:length(strong_epi_markers)) {
	# set column name to Marker_50
	colname <- paste0(strong_epi_markers[i], "_50")
	
	# add median expression for that marker for each patient to pt_epi_df
	pt_epi_df[,colname] <- sapply(1:nrow(pt_epi_df), function(x){
		pt <- pt_epi_df$patient_id[x]
		pt_expr <- sce_post_seurat[, sce_post_seurat$patient_id == pt]
		# find median expression for that patient for that marker
		median(logcounts(pt_expr[strong_epi_markers[i],]))
	})
}

# add patient-specific gene expression threshold to marker_test
marker_test$expr_threshold <- sapply(1:nrow(marker_test), function(i){
	marker <- paste0(marker_test$marker[i],"_50")
	temp <- pt_epi_df %>%
		filter(patient_id == marker_test$patient_id[i])
	
	temp[, marker]
})

# add patient's specific marker gene expression to compare against expr_threshold
marker_test$marker_expr <- sapply(1:nrow(marker_test), function(i){
	temp <- marker_test[i,]
	gene <- temp$marker
	sample_id <- temp$sample_id
	logcounts(sce_post_seurat[gene, sample_id])
})

# find sample IDs for cells that pass epithelial case 2
epi2_samples <- marker_test %>%
	filter(marker_expr > expr_threshold) %>%
	pull(sample_id)

# mark cells as epithelial if they pass case 2 OR case 1
df$epithelial <- ifelse(rownames(df) %in% epi2_samples, TRUE, df$epithelial)

# number of cells labeled as epithelial by either case
table(df$epithelial)
```


### Pull non-epithelial markers

#### Pull immune markers 

```{r}
# generic immune marker PTPRC
ptprc <- "PTPRC"

# T cell markers
tcell_markers <- cell_type_markers %>%
	filter(cell_subtype == "T cell") %>%
	pull(marker)

# B cell markers
bcell_markers <- cell_type_markers %>%
	filter(cell_subtype == "B cell") %>%
	pull(marker)

# macrophage markers
macro_markers <- cell_type_markers %>%
	filter(cell_subtype == "macrophage") %>%
	pull(marker)
```

#### T cell gene expression count

```{r}
# calculate number of T cell genes expressed above a threshold of 1 in each cell
tcell <- df[, tcell_markers]
tcell_counts <- rowSums(as.matrix(tcell))

hist(tcell_counts)
```

#### B cell gene expression count

```{r}
# calculate number of B cell genes expressed above a threshold of 1 in each cell
bcell <- df[, bcell_markers]
bcell_counts <- rowSums(as.matrix(bcell))

hist(bcell_counts)
```

#### Macrophage gene expression count

```{r}
# calculate number of macrophage genes expressed above a threshold of 1 in each cell
macro <- df[, macro_markers]
macro_counts <- rowSums(as.matrix(macro))

hist(macro_counts)
```

#### Stromal gene expression count

```{r}
# pull stromal markers
stroma_markers <- cell_type_markers %>%
	filter(cell_type == "stroma") %>%
	pull(marker)

# calculate number of stromal genes expressed above a threshold of 1 in each cell
stroma <- df[, stroma_markers]
stroma_counts <- rowSums(as.matrix(stroma))

hist(stroma_counts)
```

#### Endothelial gene expression count

```{r}
# pull endothelial markers
endo_markers <- cell_type_markers %>%
	filter(cell_type == "endothelial") %>%
	pull(marker)

# calculate number of endothelial genes expressed above a threshold of 1 in each cell
endo <- df[, endo_markers]
endo_counts <- rowSums(as.matrix(endo))

hist(endo_counts)
```

```{r}
# create data frame compiling info about non-epithelial marker counts
non_epi_df <- data.frame(sample_id = df$sample_id,
						 ptprc = df[,ptprc],
						 tcell_counts = tcell_counts,
						 bcell_counts = bcell_counts,
						 macro_counts = macro_counts,
						 stroma_counts = stroma_counts,
						 endo_counts = endo_counts)

```

### Classify immune cells

#### T cells

##### T cell case 1: only T cell immune markers

```{r}
# at least 2 T cell markers and no other immune markers
tcell_id_1 <- non_epi_df %>%
	filter(tcell_counts >= 2,
#		   epi_counts == 0,
		   bcell_counts == 0,
		   macro_counts == 0,
#		   stroma_counts == 0,
#		   endo_counts == 0
) %>%
	pull(sample_id)
```

##### T cell case 2: PTPRC and only T cell immune markers (at least 1)

```{r}
# PTPRC and 1 T cell marker with no other immune markers
tcell_id_2 <- non_epi_df %>%
	filter(ptprc == TRUE,
		   tcell_counts >= 1,
#		   epi_counts == 0,
		   bcell_counts == 0,
		   macro_counts == 0,
		   stroma_counts == 0,
		   endo_counts == 0
) %>%
	pull(sample_id)
```

##### T cell case 3: At least 3 T cell markers and no more than 1 other immune markers

```{r}
# at least 3 T cell markers and no more than 1 other immune cell marker
tcell_id_3 <- non_epi_df %>%
	filter(tcell_counts >= 3,
		   bcell_counts + macro_counts <= 1,
#		   (bcell_counts == 1 & macro_counts == 0) | (bcell_counts == 0 & macro_counts == 1),
#		   epi_counts == 0,
#		   stroma_counts == 0,
#		   endo_counts == 0
) %>%
	pull(sample_id)
```

##### Label all T cells

```{r}
tcell_id <- c(tcell_id_1, tcell_id_2, tcell_id_3)

df$tcell <- df$sample_id %in% tcell_id

table(df$tcell)
```

#### B cells

##### B cell case 1: only B cell immune markers

```{r}
# at least 2 B cell markers and no other immune markers
bcell_id_1 <- non_epi_df %>%
	filter(bcell_counts >= 2,
		   tcell_counts == 0,
		   macro_counts == 0,
#		   epi_counts == 0,
#		   stroma_counts == 0,
#		   endo_counts == 0
) %>%
	pull(sample_id)
```

##### B cell case 2: PTPRC and only B cell immune markers (at least 1)

```{r}
# PTPRC and 1 B cell marker with no other immune markers
bcell_id_2 <- non_epi_df %>%
	filter(ptprc == TRUE,
		   bcell_counts >= 1,
		   tcell_counts == 0,
		   macro_counts == 0,
#		   epi_counts == 0,
		   stroma_counts == 0,
		   endo_counts == 0
) %>%
	pull(sample_id)
```

##### B cell case 3: At least 3 B cell markers and no more than 1 other immune markers

```{r}
# at least 3 B cell markers and no more than 1 other immune cell marker
bcell_id_3 <- non_epi_df %>%
	filter(bcell_counts >= 3,
		   tcell_counts + macro_counts <= 1,
#		   (tcell_counts == 1 & macro_counts == 0) | (tcell_counts == 0 & macro_counts == 1),
#		   epi_counts == 0,
#		   stroma_counts == 0,
#		   endo_counts == 0
) %>%
	pull(sample_id)
```

##### Label all B cells

```{r}
bcell_id <- c(bcell_id_1, bcell_id_2, bcell_id_3)

df$bcell <- df$sample_id %in% bcell_id

table(df$bcell)
```

#### Macrophages

##### Macrophage case 1: only macrophage immune markers

```{r}
# at least 2 macrophage markers and no other immune markers
macro_id_1 <- non_epi_df %>%
	filter(macro_counts >= 2,
		   tcell_counts == 0,
		   bcell_counts == 0,
#		   epi_counts == 0,
#		   stroma_counts == 0,
#		   endo_counts == 0
) %>%
	pull(sample_id)
```

##### Macrophage case 2: PTPRC and only macrophage immune markers (at least 1)

```{r}
# PTPRC and 1 macrophage marker with no other immune markers
macro_id_2 <- non_epi_df %>%
	filter(ptprc == TRUE,
		   macro_counts >= 1,
		   tcell_counts == 0,
		   bcell_counts == 0,
#		   epi_counts == 0,
		   stroma_counts == 0,
		   endo_counts == 0
) %>%
	pull(sample_id)
```

##### Macrophage case 3: At least 3 macrophage markers and no more than 1 other immune markers

```{r}
# at least 3 macrophage markers and no more than 1 other immune cell marker
macro_id_3 <- non_epi_df %>%
	filter(macro_counts >= 3,
		   tcell_counts + bcell_counts <= 1,
#		   epi_counts == 0,
#		   stroma_counts == 0,
#		   endo_counts == 0
) %>%
	pull(sample_id)
```

##### Label all macrophages

```{r}
macro_id <- c(macro_id_1, macro_id_2, macro_id_3)

df$macro <- df$sample_id %in% macro_id

table(df$macro)
```


### Classify stromal and endothelial cells

#### Stromal cells

##### Stromal cell case 1: Only stromal markers

```{r}
stroma_id_1 <- non_epi_df %>%
	filter(stroma_counts > 0,
		   endo_counts == 0,
		   epi_counts == 0,
		   tcell_counts == 0,
		   bcell_counts == 0,
		   macro_counts == 0) %>%
	pull(sample_id)
```


##### Stromal cell case 2: At least 3 stromal markers and no more than 1 endothelial marker

```{r}
stroma_id_2 <- non_epi_df %>%
	filter(stroma_counts >= 3,
		   endo_counts <= 1) %>%
	pull(sample_id)
```

##### Label all stromal cells

```{r}
stroma_id <- unique(c(stroma_id_1, stroma_id_2))

df$stromal <- df$sample_id %in% stroma_id

table(df$stromal)
```

#### Endothelial cells

##### Endothelial cell case 1: Only endothelial markers

```{r}
endo_id_1 <- non_epi_df %>%
	filter(endo_counts > 0,
		   epi_counts == 0,
		   stroma_counts == 0,
		   tcell_counts == 0,
		   bcell_counts == 0,
		   macro_counts == 0) %>%
	pull(sample_id)
```


##### Endothelial cell case 2: At least 3 endothelial markers and no more than 1 stromal marker

```{r}
endo_id_2 <- non_epi_df %>%
	filter(endo_counts >= 3,
		   stroma_counts <= 1) %>%
	pull(sample_id)
```

##### Label all endothelial cells

```{r}
endo_id <- unique(c(endo_id_1, endo_id_2))

df$endothelial <- df$sample_id %in% endo_id

table(df$endothelial)
```

### Decide cell type 

```{r}
# create data frame with only the cell type labels of interest
type_df <- as.data.frame(df) %>%
	select(sample_id, patient_id, epithelial, tcell, bcell, macro, stromal, endothelial)

# identify cells that are only labeled epithelial OR only labeled epithelial/stromal
epi_only_id <- type_df %>%
	filter(epithelial, !tcell, !bcell, !macro, !endothelial) %>%  # don't remove things classified as epi + stroma (EMT)
	pull(sample_id)

# identify cells that are only labeled T cells
t_only_id <- type_df %>%
	filter(tcell, !epithelial, !bcell, !macro, !stromal, !endothelial) %>%
	pull(sample_id)

# identify cells that are only labeled B cells
b_only_id <- type_df %>%
	filter(bcell, !epithelial, !tcell, !macro, !stromal, !endothelial) %>%
	pull(sample_id)

# identify cells that are only labeled macrophages
macro_only_id <- type_df %>%
	filter(macro, !epithelial, !tcell, !bcell, !stromal, !endothelial) %>%
	pull(sample_id)

# identify cells that are only labeled stromal cells
stromal_only_id <- type_df %>%
	filter(stromal, !epithelial, !tcell, !bcell, !macro, !endothelial) %>%
	pull(sample_id)

# identify cells that are only labeled endothelial cells
endo_only_id <- type_df %>%
	filter(endothelial, !epithelial, !tcell, !bcell, !macro, !stromal) %>%
	pull(sample_id)

# identify cells that are not labeled as any of the 6 types
unknown_id <- type_df %>%
	filter(!epithelial, !tcell, !bcell, !macro, !stromal, !endothelial) %>%
	pull(sample_id)

# identify cells that are labeld as 2 or more types (excluding epithelial/stromal only)
undecided_id <- type_df %>%
	filter(!(sample_id %in% c(epi_only_id, t_only_id, b_only_id, macro_only_id,
							  stromal_only_id, endo_only_id, unknown_id))) %>%
	pull(sample_id)

# compile a vector with the assigned cell type for each cell
lit_cell_type <- type_df %>%
	mutate(cell_type = case_when(
		sample_id %in% epi_only_id ~ "epithelial",
		sample_id %in% t_only_id ~ "T cell",
		sample_id %in% b_only_id ~ "B cell",
		sample_id %in% macro_only_id ~ "macrophage",
		sample_id %in% stromal_only_id ~ "stromal",
		sample_id %in% endo_only_id ~ "endothelial",
		sample_id %in% unknown_id ~ "unknown",
		sample_id %in% undecided_id ~ "undecided"
	)) %>%
	pull(cell_type)

# inspect numbers of each assigned cell type in dataset
table(lit_cell_type)
```

### Save updated SingleCellExperiment with annotations

```{r}
# update sce_post_seurat with literature-based cell type annotation
sce_post_seurat$lit_cell_type <- lit_cell_type
save(sce_post_seurat, file = "rdata/sce_post_seurat.rda")

# update tnbc_seurat with literature-based cell type annotation
tnbc_seurat$lit_cell_type <- lit_cell_type
save(tnbc_seurat, file = "rdata/tnbc_seurat.rda")
```

### Cell type proportions bar graph

```{r}
# create barplot of cell type proportions per patient
type_prop_barplot <- as.data.frame(colData(sce_post_seurat)) %>%
	group_by(patient_id, lit_cell_type) %>%
	summarize(n=n()) %>%
	ggplot(aes(patient_id, n, fill = lit_cell_type)) +
	geom_bar(stat = "identity", position = "fill") +
	xlab("Patient ID") +
	ylab("Proportion of cells") +
	scale_fill_manual (values = colorblind_palette) +
    ggtitle("Cell type proportions per patient")

# inspect cell type proportion barplot
type_prop_barplot

# save cell type proportion barplot
ggsave(type_prop_barplot, filename = "results/type-prop-barplot.png", height = 4, width = 6)
```

### Cell type counts bar graph

```{r}
# create barplot of cell type counts per patient
type_count_barplot <- as.data.frame(colData(sce_post_seurat)) %>%
	group_by(patient_id, lit_cell_type) %>%
	summarize(n=n()) %>%
	ggplot(aes(patient_id, n, fill = lit_cell_type)) +
	geom_bar(stat = "identity") +
	scale_fill_manual(values = colorblind_palette) +
	xlab("Patient ID") +
	ylab("Number of cells")  +
    ggtitle("Cell type counts per patient")

# inspect cell type count barplot
type_count_barplot

# save cell type count barplot
ggsave(type_count_barplot, filename = "results/type-count-barplot.png", height = 4, width = 6)
```
###  Visualize marker gene based cell types with tSNE and UMAP

#### tSNE plot of marker-based cell types

```{r}
# color tSNE with literature-based cell types
tsne_lit_cell_type <- DimPlot(tnbc_seurat, reduction = "tsne",
		group.by = "lit_cell_type",
		label = TRUE, label.size = 4, repel = TRUE) +
	ggtitle("tSNE plot of literature-based cell types") +
	scale_color_manual(values = colorblind_palette)

# inspect tSNE plot with literature-based cell types
tsne_lit_cell_type

# save tSNE plot with literature-based cell types
ggsave(tsne_lit_cell_type, filename = "results/tsne-lit-cell-types.png", width = 7, height = 4)

```

#### UMAP plot of marker-based cell types


```{r}
# color UMAP with literature-based cell types
umap_lit_cell_type <- DimPlot(tnbc_seurat, reduction = "umap",
		group.by = "lit_cell_type",
		label = TRUE, label.size = 4, repel = TRUE) +
	ggtitle("UMAP plot of literature-based cell types") +
	scale_color_manual(values = colorblind_palette)

# inspect UMAP plot with literature-based cell types
umap_lit_cell_type

# save UMAP plot with literature-based cell types
ggsave(umap_lit_cell_type, filename = "results/umap-lit-cell-types.png", width = 7, height = 4)
```
### Find genes differentially expressed across cell types

```{r}
# set identity for finding markers to literature-based cell type
tnbc_seurat <- SetIdent(tnbc_seurat, value = "lit_cell_type")

# find marker genes differentially expressed in each literature-based cell type compared to other types
celltype_markers <- FindAllMarkers(tnbc_seurat, logfc.threshold = 0.5, slot = "scale.data")

# keep only differentially expressed markers with an adjusted pval less than .05
celltype_markers <- celltype_markers %>%
	filter(p_val_adj <= .05)

save(celltype_markers, file = "rdata/celltype_markers.rda")

# find top 5 differentially expressed genes for each cell type
top5 <- celltype_markers %>%
	group_by(cluster) %>%
	top_n(5, wt = avg_diff)

# create heatmap of top 5 DE genes for each cell type
celltype_de_heat <- DoHeatmap(tnbc_seurat, features = top5$gene, size = 3, angle = 40, slot = "scale.data",
                              group.colors = colorblind_palette[c(3, 4, 8, 5, 7, 1, 2, 6)])

# inspect heatmap
celltype_de_heat

# save heatmap of top 5 DE genes for each cell type
ggsave(celltype_de_heat, filename = "results/type-de-genes-heat.png", width = 8, height = 6)
```


## SC3 consensus k-means clustering

*Important:* Exact SC3 consensus clusters will differ every time this code is run, despite seeds being set. SC3 code was run once but is now marked to `eval=FALSE` so it will not overwrite itself. My output data are available upon request.

### Format SingleCellExperiment for SC3

```{r}
# subset raw count assay to the filtered genes and filtered cells
sce_sc3 <- sce_tpm[rownames(sce),colnames(sce)]

# add normalized counts (slot is required to be named logcounts for compatibility with SC3)
assay(sce_sc3, "logcounts") <- assay(sce)
```

### Perform SC3 clustering

Instead of performing sc3 as a single wrapper call (`sc3(sce_sc3, ks = ...)`), perform it piece-wise so k can be estimated with `sc3_estimate_k`.

The optimal value of k was estimated using the `sc3_estimate_k` function from SC3. "SC3 utilizes the Tracy-Widom theory on random matrices to estimate k" (Kiselev et al., 2017).

```{r}
# prepare default parameters
sce_sc3 <- sc3_prepare(sce_sc3)

# estimate optimal k
set.seed(42)   # I don't think the estimation is stochastic, but adding this just in case
sce_sc3 <- sc3_estimate_k(sce_sc3)

# show estimated optimal k
metadata(sce_sc3)$sc3$k_estimation
```



```{r eval=FALSE}
# calculate distances between cells
sce_sc3 <- sc3_calc_dists(sce_sc3)

# transform distance matrices with PCA and graph Laplacian
sce_sc3 <- sc3_calc_transfs(sce_sc3)

# perform k-means clustering with estimated optimal k
set.seed(42)    # again, not sure this next step is stochastic, but it very well may be because k-means usually is
sce_sc3 <- sc3_kmeans(sce_sc3, ks = 29)

# calculate consensus matrix for the clustering results using various distance metrics, transformations, and random seeds
sce_sc3 <- sc3_calc_consens(sce_sc3)

# check that all cells are in the same order in both the sce_sc3 and Seurat objects
all(colnames(tnbc_seurat) == colnames(sce_sc3))

# add clusters to Seurat object
tnbc_seurat$sc3_29_clusters <- sce_sc3$sc3_29_clusters
```

```{r}
# load results from clustering
load("rdata/tnbc_seurat_sc3.rda")

# number of cells per cluster
table(tnbc_seurat$sc3_29_clusters)
```


### Visualize SC3 clusters

#### tSNE plot of SC3 clusters

```{r}
# color tSNE plot with SC3 clusters
tsne_sc3_k29 <- DimPlot(tnbc_seurat, reduction = "tsne",
		group.by = "sc3_29_clusters",
		label = TRUE, label.size = 5, repel = TRUE) +
	ggtitle("tSNE plot of SC3 clusters with k=29")

# inspect tSNE plot colored by SC3 clusters
tsne_sc3_k29

# save tSNE plot colored by SC3 clusters
ggsave(tsne_sc3_k29, filename = "results/tsne-sc3-k29-clusters.png", width = 7, height = 4)
```

#### UMAP plot of SC3 clusters

```{r}
# color UMAP plot with SC3 clusters
umap_sc3_k29 <- DimPlot(tnbc_seurat, reduction = "umap",
		group.by = "sc3_29_clusters",
		label = TRUE, label.size = 5, repel = TRUE) +
	ggtitle("UMAP plot of SC3 clusters with k=29")

# inspect UMAP plot colored by SC3 clusters
umap_sc3_k29

# save UMAP plot colored by SC3 clusters
ggsave(umap_sc3_k29, filename = "results/umap-sc3-k29-clusters.png", width = 7, height = 4)
```

### Find genes differentially expressed across SC3 clusters

```{r eval=FALSE}
# find marker genes for sc3 clusters
tnbc_seurat <- SetIdent(tnbc_seurat, value = "sc3_29_clusters")
sc3_k29_markers <- FindAllMarkers(tnbc_seurat, logfc.threshold = 0.5, slot = "scale.data")

# keep only differentially expressed markers with an adjusted pval less than .05
sc3_k29_markers <- sc3_k29_markers %>%
	filter(p_val_adj <= .05)

save(sc3_k29_markers, file = "sc3_k29_markers.rda")
```

```{r}
load("rdata/sc3_k29_markers.rda")

# show top 10 marker genes per cluster (top 5 were insufficient to show good patterns)
top10 <- sc3_k29_markers %>%
	group_by(cluster) %>%
	top_n(10, wt = avg_diff)

# create heatmap of top 10 genes differentially expressed across SC3 clusters
sc3_de_heat <- DoHeatmap(tnbc_seurat, features = top10$gene, size = 3) + NoLegend() +
	theme(axis.text.y = element_blank())

# inspect heatmap of SC3 cluster differentially expressed genes
sc3_de_heat

# save heatmap of SC3 cluster differentially expressed genes
ggsave(sc3_de_heat, filename = "results/sc3-de-heat.png", width = 10, height = 10)
```

Some clusters seem composed of cells with unique expression patterns of the top 10 differentially expressed genes identified for each cluster. (for example, 6, 26, 28, 29). Other groups of distinct clusters seem to have highly similar patterns of differential expression (for example, 9-10 and 8-19-20), suggesting this approach may not be returning the most parsimonious group of biologically relevant clusters. Still other clusters had few or no distinguishing expression patterns across the set of top 10 differentially expressed genes per cluster (for example, 1, 3, 17, 18). Additional clusters had an extremely small number of cells (cluster 2 = 1 cell, cluster 5 = 5 cells, cluster 16 = 6 cells, cluster 22 = 8 cells) and may not reflect biologically meaningful subsets or may represent populations that are too rare to characterize with statistical confidence. Combined, these results suggest that the estimated optimal value of $k$ from SC3 may result in overly fine resolution of clusters and that the true number of clusters is less than 29.

